**01.sh**

"Hello World!"

![01](images/01.png)

**02.sh**

Вывести:
* Текст с переносом строки
* Текст без переноса строки

Для второго случая использовать `echo` с необходимым параметром. Для просмотра доступных параметров можно воспользоваться командой `help echo`

![02](images/02.png)

**03.sh**

Написать скрипт, включающий в себя:
* Однострочный комментарий
* Многострочный комментарий

![03](images/03.png)

*Хинт: для второго случая использовать следующую конструкцию комментария:*

```
: '
text
text
..
'
```

Вывести после каждого комментария результат каких-либо вычислений:

```
((res=4+5))
echo $res
```

**04.sh**

Вывести последовательность чисел от 1 до 10 с использованием цикла `while`

![04](images/04.png)

**05.sh**

Вывести в одну строчку через пробел последовательность чисел от 10 до 1 с использованием цикла `for` и декремента. После завершения работы цикла добавить перенос строки:

![05](images/05.png)

**06.sh**

Получить имя пользователя с помощью команды `read` и вывести приветствие:

![06](images/06.png)

**07.sh**

Используя условный оператор `if` выполнить проверку на количество введенных пользовтелем символов. Если пользователь не ввел ни одного символа -- вывести соответсвующее сообщение. Иначе -- вывести пользовательское сообщение:

![07](images/07.png)

**08.sh**

Реализовать "форму авторизации". Запросить с помощью `read` "логин" и "пароль". В случае ввода определенной комбинации (например `admin:123456`) вывести сообщение об успехе. Иначе -- сообщение об ошибке. Использовать оператор `&&`.

![08](images/08.png)

**09.sh**

Реализовать скрипт, определяющий принадлежность введенного пользователем слова к названию времен года _(winter, spring, summer, autumn)_. Использовать условный оператор `||`. Если введено время года -- вывести "Correct!", иначе -- "Incorrect!"

![09](images/09.png)

**10.sh**

Доработать скрипт **09.sh** добавив отдельный вывод для одного из корректных вариантов ввода. Использовать оператор `elif`.

![10](images/10.png)

**11.sh**

Доработать скрипт **10.sh**, использовав оператор `case`.

![11](images/11.png)

**12.sh**

Реализовать скрипт, принимающий и выводящий в одну строчку 2 аргумента. На второй строчке вывести количество переданных аргументов (используя конструкцию языка для подсчета).

![12](images/12.png)

**13.sh**

Реализовать скрипт, выводящий таблицу умножения на 2. Использовать цикл `for` или `while`.

![13](images/13.png)

**14.sh**

Реализовать скрипт, рассчитывающий сумму введенных чисел, реализовав функцию `function Sum()` и вызвав ее. Ввод слагаемых считывать с помощью `read`.

![14](images/14.png)

**15.sh**

Реализовать скрипт, ожидающий ввод числа и определяющий принадлежность этого числа к множеству четных/нечетных чисел.

![15](images/15.png)

**16.sh**

Реализовать скрипт, выводящий "шапку" таблицы процессов и последний процесс в приведенном ниже формате. Использовать по отдельности команды `head` и `tail` с необходимыми аргументами.

![16](images/16.png)

**17.sh**

Реализовать скрипт, возвращающий количество доступных процессоров. Использовать информацию из `/proc/cpuinfo`.

![17](images/17.png)

**18.sh**

Реализовать скрипт, проверяющий наличие файла. Путь до файла передавать первым аргументом при вызове.

![18](images/18.png)

**19.sh**

Реализовать скрипт, принимающий первым аргументом название файла; создающий его; выводящий листинг по названию файла; удаляющий файл; повторно выводящий листинг. Использовать команды `touch`, `ls`, `rm`.

![19](images/19.png)

**20.sh**

Реализовать скрипт, создающий папку. В случае, если папка уже существует, вывести сообщение об этом и закончить выполнение. Название папки получить через `read`.

![20](images/20.png)

**21.sh**

Реализовать скрипт, вычитывающий содержимое файла line-by-line. Путь до файла передать первым аргументом при вызове. Использовать конструкцию `while read line; do`.

![21](images/21.png)

**22.sh**

Реализовать скрипт, выводящий случайное число. Правую границу диапазона передать первым аргументом при вызове.

![22](images/22.png)

**23.sh**

Реализовать скрипт, выводящий дату запуска и дату завершения его работы. Между двумя выводами использовать `sleep`. Количество секунд передать в первом аргументе при запуске. 

![23](images/23.png)

**24.sh**

Реализовать скрипт, выводящий "раскрашенный" первый аргумент.

![24](images/24.png)

**25.sh**

Реализовать скрипт, определяющий размер директории (`du`). Отобразить вывод в human-readable формате. Путь до целевой директории передать первым аргументом.

![25](images/25.png)

**26.sh**

Реализовать скрипт, инициирующий 2 процесса (например, `sleep 1 &`), и завершающийся после завершения последнего из процессов (`wait`).

![26](images/26.png)

**27.sh**

Реализовать скрипт, конвертирующий Unix time в human-readable дату. Исходное значение Unix time передавать первым аргументом.

![27](images/27.png)

**28.sh**

Реализовать скрипт создания временной директории. Использовать механизмы ОС.

![28](images/28.png)

**29.sh**

Реализовать скрипт, выводящий количество символов в самой длинной строке файла. Путь до исходного файла передавать первым аргументом.

![29](images/29.png)

**30.sh**

Реализовать скрипт, возвращающий дату последнего изменения файла. Путь до исходного файла передавать первым аргументом.

![30](images/30.png)
